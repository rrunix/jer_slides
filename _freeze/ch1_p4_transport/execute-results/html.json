{
  "hash": "810d93d84070a3f1a7012ccea3cb59b9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Capa de Transporte\"\nsubtitle: \"Comunicación lógica entre procesos de aplicación\"\nauthor: \"Rubén Rodríguez Fernández (@rrunix)\"\ndate: \"23/09/2025\"\n\nmermaid:\n      theme: default\n---\n\n# Introducción\n\n## ¿Qué es la Capa de Transporte?\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Función principal:**\n\nProporciona comunicación lógica entre procesos de aplicación que se ejecutan en diferentes hosts\n\n- Se ejecuta en hosts finales\n- No en el núcleo de la red\n- Divide mensajes en segmentos\n- Recompone segmentos en el receptor\n:::\n\n::: {.column width=\"50%\"}\n**Protocolos principales:**\n\n- **UDP**: Protocolo minimalista\n- **TCP**: Protocolo complejo con garantías\n\nLa elección depende del dominio y la aplicación\n:::\n:::\n\n## Ejemplo: Cliente-Servidor con UDP\n\n::: {style=\"width: 50vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 4\n%%| fig-align: center\nsequenceDiagram\n    participant A as Client A\n    participant I as The Internet\n    participant B as Server B\n        \n    A->>I: Paquete UDP 1 (IP destino: 8.8.8.8, puerto: 80)\n    I->>B: Paquete 1 entregado\n    \n    A->>I: Paquete UDP 2 (IP destino: 8.8.8.8, puerto:80)\n    I->>B: Paquete 2 entregado\n    \n    A->>I: Paquete UDP 3 (IP destino: 8.8.8.8, puerto:80)\n    \n    A->>I: Paquete UDP 4 (IP destino: 8.8.8.8, puerto:80)\n    I->>B: Paquete 4 entregado (llega primero!)\n    A->>I: Paquete UDP 5 (IP destino: 8.8.8.8, puerto:80)\n    I->>B: Paquete 3 entregado (llega tarde!)\n```\n:::\n\n\n- Paquete 5: perdido (~1% pérdida normal)\n- Paquete 4 llega antes que el 3\n- UDP no corrige orden ni pérdidas\n\n\n# Funciones Principales\n\n## 1. Multiplexación y Demultiplexación\n\n**Multiplexación:** Recoger información de diferentes sockets y enviarla por un único medio.\n\n**Demultiplexación:** Recibir segmentos y enviarlos a los sockets correspondientes.\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Identificación de sockets:**\n\n- TCP: (IP y Puerto origen, IP y puerto destino)\n- UDP: ([IP y puerto origen]{style=\"color:red;\"}, IP y puerto destino)\n:::\n::: {.column width=\"50%\"}\n**Puertos:** Identificadores numéricos (1-65535)\n\n- Servidores: asignación manual y fija\n- Clientes: asignación aleatoria\n:::\n:::\n\n```{mermaid}\ngraph LR\n    subgraph \"MULTIPLEXACIÓN\"\n        A1[Socket 1<br/>App A] --> M[Multiplexor<br/>Capa de Transporte]\n        A2[Socket 2<br/>App B] --> M\n        A3[Socket 3<br/>App C] --> M\n        M --> N[Red<br/>Medio único]\n    end\n    \n    subgraph \"DEMULTIPLEXACIÓN\"\n        N2[Red<br/>Segmentos entrantes] --> D[Demultiplexor<br/>Capa de Transporte]\n        D --> B1[Socket 1<br/>App A]\n        D --> B2[Socket 2<br/>App B]\n        D --> B3[Socket 3<br/>App C]\n    end\n    \n    N -.->|Transmisión| N2\n    \n    classDef appClass fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n    classDef muxClass fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef netClass fill:#fff3e0,stroke:#f57c00,stroke-width:2px\n    \n    class A1,A2,A3,B1,B2,B3 appClass\n    class M,D muxClass\n    class N,N2 netClass\n```\n\n\n\n## 2. Transferencia Fiable\n\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Características de una transferencia fiable:**\n\n\n- No se corrompe ningún bit\n- No se pierde información (paquetes)\n- La información se entrega en orden correcto\n:::\n::: {.column width=\"50%\"}\n\n**Opciones de implementación:**\n\n1. Usar protocolos fiables existentes (TCP)\n2. Implementar características propias sobre protocolo no fiable (UDP + lógica aplicación)\n:::\n:::\n\n\n```{mermaid}\ngraph LR\n    \n    E[EMISOR] --> PC1[PROTOCOLO<br/>CONFIABILIDAD]\n    PC1 --> MNF[MEDIO<br/>NO FIABLE<br/><br/>• Puede corromper bits<br/>• Puede perder paquetes<br/>• Puede desordenar]\n    MNF --> PC2[PROTOCOLO<br/>CONFIABILIDAD]\n    PC2 --> R[RECEPTOR]\n    \n    PC1 -.->|Implementa| MECH[• Detección de errores<br/>• Retransmisión<br/>• Control de flujo<br/>• Secuenciación<br/>• ACK/NACK<br/>• Timeouts]\n    PC2 -.->|Implementa| MECH\n    \n    classDef endpointClass fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef protocolClass fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n    classDef unreliableClass fill:#ffebee,stroke:#d32f2f,stroke-width:2px\n    classDef reliableClass fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef mechClass fill:#fafafa,stroke:#616161,stroke-width:1px\n    \n    class E,R endpointClass\n    class PC1,PC2 protocolClass\n    class MNF unreliableClass\n    class MECH mechClass\n```\n\n# UDP (User Datagram Protocol)\n\n## Características de UDP\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Protocolo minimalista [RFC 768]:**\n\n- Basado en best-effort\n- No orientado a conexión\n- Entrega no fiable y sin orden\n- Integridad básica (checksum)\n- Multiplexación y demultiplexación\n:::\n\n::: {.column width=\"50%\"}\n**Lo que NO proporciona:**\n\n- Control de flujo\n- Control de congestión\n- Temporización\n- Tasa de transferencia mínima\n- Seguridad\n:::\n:::\n\n::: {.fragment}\n**\"Fire-and-forget\":** Envías el paquete y te olvidas, independientemente de si llega\n:::\n\n## Estructura del Paquete UDP\n\n```{mermaid}\n%%| fig-height: 6\n%%| fig-align: center\n%%| out-width: \"80%\"\npacket-beta\n\n    0-15: \"Source Port\"\n    16-31: \"Destination Port\"\n    32-47: \"Length\"\n    48-63: \"Checksum\"\n```\n\n- **Longitud:** Hasta 65535 bytes (limitado por MTU)\n- **Checksum:** Verificación de integridad\n- Estructura simple comparada con otros protocolos\n\n\n## Checksum UDP\n\n**Proceso de cálculo:**\n\n1. Preparación: pseudo-cabecera IP + cabecera UDP + datos\n2. División en palabras de 16 bits\n3. Suma usando aritmética de complemento a uno\n4. Complemento del resultado → campo checksum\n\n\n**Verificación en receptor:**\n\n- Mismo algoritmo incluyendo checksum recibido\n- Resultado esperado: 0xFFFF\n- Si difiere: datagrama descartado silenciosamente\n\n\n## Casos de Uso de UDP\n\n**Aplicaciones ideales para UDP:**\n\n- **Multimedia streaming:** Tolerante a pérdidas, sensible a interrupciones\n- **DNS:** Respuestas rápidas necesarias\n- **SNMP:** Administración de red\n- **Gaming online:** Latencia baja crítica\n- **QUIC/HTTP3:** Base para protocolos modernos optimizados\n\nEjemplo: Implementar protocolo propio sobre UDP para juegos\n\n- Añadir número de paquete\n- Descartar paquetes fuera de orden\n- Ignorar duplicados\n- Sobrecarga mínima\n\n# TCP (Transmission Control Protocol)\n\n## Características de TCP\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**Protocolo confiable [RFC 793]:**\n\n- Orientado a conexión\n- Entrega fiable y ordenada\n- Control de flujo\n- Control de congestión\n- Multiplexación y demultiplexación\n:::\n\n::: {.column width=\"50%\"}\n**Lo que NO proporciona:**\n\n- Temporización específica\n- Tasa mínima garantizada\n- Seguridad nativa (necesita TLS/SSL)\n:::\n:::\n\n\n**Trade-off:** Confiabilidad y orden sobre velocidad pura\n\n\n## Estructura del Paquete TCP\n\n::: {style=\"width: 50vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 6\n%%| fig-align: center\n%%| out-width: \"80%\"\npacket-beta\n  0-15: \"Source Port\"\n  16-31: \"Destination Port\"\n  32-63: \"Sequence Number\"\n  64-95: \"Acknowledgment Number\"\n  96-99: \"Data Offset\"\n  100-105: \"Reserved\"\n  106: \"URG\"\n  107: \"ACK\"\n  108: \"PSH\"\n  109: \"RST\"\n  110: \"SYN\"\n  111: \"FIN\"\n  112-127: \"Window\"\n  128-143: \"Checksum\"\n  144-159: \"Urgent Pointer\"\n  160-191: \"Options (variable)\"\n```\n:::\n- **Sequence number**: Número que identifica la posición del primer byte de datos en el segmento dentro del flujo de datos.\n- **Ack number**: Indica el próximo número de secuencia que el receptor espera recibir. Confirma la recepción correcta de datos anteriores.\n- **Window:** Implementa control de flujo (bytes que receptor acepta)\n\n## Handshake de Tres Fases\n\n::: {style=\"width: 38vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 4\n%%| fig-align: center\nsequenceDiagram\n    participant CS as Cliente Socket\n    participant SS as Server Socket (listen)\n    participant NS as Nuevo Socket\n    \n    Note over CS: Estado: CLOSED\n    Note over SS: Estado: LISTEN\n    CS->>SS: SYN=1, seq=x\n    Note over CS: Estado: SYN_SENT\n    Note over SS: accept() crea nuevo socket\n    SS->>NS: Deriva conexión\n    Note over NS: Estado: SYN_RCVD\n    NS->>CS: SYN=1, ACK=1, seq=y, ack=x+1\n    Note over CS: Estado: ESTABLISHED\n    CS->>NS: ACK=1, seq=x+1, ack=y+1\n```\n:::\n\n- Se negocian: MSS, opciones de ventana, extensiones TCP\n- Los flags de las cabeceras también consumen bits.\n\n\n## Mecanismos de Confiabilidad\n\n**Números de secuencia y ACKs:**\n\n- Cada byte tiene número único\n- ACKs acumulativos (ACK para byte N confirma hasta N-1)\n\n\n**Detección de pérdidas - Dos métodos:**\n\n- Detección de timeout\n- Detección de ACKs duplicados\n\n\n## Detección por Timeout\n\n```{mermaid}\n%%| fig-width: 6\n%%| fig-height: 4\nsequenceDiagram\n    participant E as Emisor\n    participant R as Receptor\n    E ->> X: seq=100, data=\"A\", Paquete perdido\n    Note over E: Timeout de seq:100, reenvio\n    E ->> R: seq=100, data=\"A\",\n```\n\n\nSi no recibe ACK en tiempo determinado → asume pérdida y retransmite\n\n\n## Detección por ACKs Duplicados\n\n::: {style=\"width: 38vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-width: 6\n%%| fig-height: 4\nsequenceDiagram\n    participant E as Emisor\n    participant R as Receptor\n    E ->> X: seq=100, data=\"A\", Paquete perdido\n    E ->> R: seq=101, data=\"B\"\n    E ->> R: seq=102, data=\"C\"\n    E ->> R: seq=103, data=\"D\"\n    R ->> E: ACK=100\n    R ->> E: ACK=100\n    R ->> E: ACK=100\n    Note over E,R: Retransmisión rápida\n    E ->> R: seq=100, data=\"A\"\n```\n:::\n\n3 ACKs duplicados → Fast Retransmit inmediato\n\n\n## Control de Flujo\n\n::: {style=\"width: 38vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 4\n%%| fig-align: center\nsequenceDiagram\n    participant E as Emisor\n    participant R as Receptor\n    \n    Note over R: Buffer: 4KB libres\n    R->>E: ACK=1000, Window=4096\n    E->>R: seq=1000, data=2KB\n    Note over R: Buffer: 2KB libres\n    R->>E: ACK=3000, Window=2048\n    E->>R: seq=3000, data=2KB\n    Note over R: Buffer: 0KB libres (lleno)\n    R->>E: ACK=5000, Window=0\n    Note over E: Detiene envío, inicia probe timer\n```\n:::\n\n```\nVentanaRecepcion = BufferRecepcion - (UltimoByteRecibido - UltimoByteLeido)\n```\n\n## Control de Congestión\n\n**Ventana de congestión:**\n\n- Variable del emisor\n- Bytes máximos en \"el aire\" (enviados sin ACK)\n- Tasa efectiva = min(VentanaCongestion, VentanaRecepcion)\n\n## Slow Start\n\n::: {style=\"width: 38vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 4\nsequenceDiagram\n    participant E as Emisor\n    participant R as Receptor\n    \n    Note over E: Slow Start: cwnd=1 MSS\n    E->>R: seq=1000, MSS=1KB\n    R->>E: ACK=2000\n    Note over E: cwnd=2 MSS\n    E->>R: seq=2000, MSS=1KB\n    E->>R: seq=3000, MSS=1KB\n    R->>E: ACK=3000\n    R->>E: ACK=4000\n    Note over E: cwnd=4 MSS (crecimiento exponencial)\n    Note over E: ... continúa hasta threshold o detectar pérdida ...\n```\n:::\n\n## Congestion Avoidance  \n\n::: {style=\"width: 36vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 4\nsequenceDiagram\n    participant E as Emisor\n    participant R as Receptor\n    \n    Note over E: Congestion Avoidance: cwnd=1 MSS\n\n    E->>R: seq=1000, MSS=1KB\n    R->>E: ACK=2000\n\n    Note over E: cwnd=2 MSS\n\n    E->>R: seq=2000, MSS=1KB\n    E->>R: seq=3000, MSS=1KB\n    R->>E: ACK=3000\n    R->>E: ACK=4000\n\n    Note over E: cwnd=3 MSS (crecimiento lineal)\n    Note over E: ... continúa hasta detectar pérdida ...\n```\n:::\n\n## Eventos de Congestión\n\n**Respuesta a pérdidas:**\n\n- **Timeout:** \n\n  - Pérdida severa\n  - Ventana → 1 MSS\n  - Modo slow start\n\n- **3 ACKs duplicados:**\n\n  - Pérdida moderada\n  - Ventana → mitad\n  - Continúa congestion avoidance\n\nCrea patrón \"diente de sierra\" en throughput\n\n## Ejemplo de patrón de sierra\n::: {style=\"width: 40vw; text-align: center; margin: 0 auto;\"}\n\n::: {#b4cf90eb .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n```\n<Figure size 1344x768 with 0 Axes>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](ch1_p4_transport_files/figure-revealjs/cell-2-output-2.png){width=1140 height=562}\n:::\n:::\n\n\n:::\n\n## Terminación de Conexión\n\n::: {style=\"width: 28vw; text-align: center; margin: 0 auto;\"}\n```{mermaid}\n%%| fig-height: 4\nsequenceDiagram\n    participant C as Cliente\n    participant S as Servidor\n    \n    Note over C,S: Conexión establecida\n    C->>S: FIN=1, seq=x\n    Note over C: Estado: FIN_WAIT_1\n    S->>C: ACK=1, ack=x+1\n    Note over C: Estado: FIN_WAIT_2\n    S->>C: FIN=1, ACK=1, seq=y\n    Note over S: Estado: LAST_ACK\n    C->>S: ACK=1, ack=y+1\n    Note over C: Estado: TIME_WAIT\n    Note over C: Espera 2*MSL\n    Note over C,S: CLOSED\n```\n:::\n\n## Equidad y Coexistencia\n\n**TCP es \"fair\":**\n\n- N conexiones TCP comparten enlace equitativamente\n- Cada una obtiene ~R/N del ancho de banda R\n\n::: {.fragment}\n**Limitaciones:**\n\n- UDP no implementa control → puede monopolizar\n- Aplicaciones con múltiples conexiones TCP\n- Conexiones con menor RTT tienen ventaja\n:::\n\n# Comparativa TCP vs UDP para Videojuegos\n\n## Cuándo usar UDP\n\n**Requisitos para UDP:**\n\n- Latencias < 50ms\n- Actualizaciones frecuentes\n- Información nueva más valiosa que la vieja\n\n\n**Ventajas:**\n\n- Cabeceras pequeñas\n- Sin tráfico de control\n- Servidor necesita menos recursos\n- No mantiene estado\n\n**Ejemplos:** Shooters (Counter Strike), juegos de lucha\n\n## Cuándo usar TCP\n\n**Requisitos para TCP:**\n- Tolerancia 100-200ms latencia\n- Entrega ordenada garantizada\n- Detección y corrección de errores\n\n**Consideraciones:**\n- Bloqueo cabeza de línea\n- Latencias variables por retransmisiones\n- Mayor tráfico de red\n\n**Ejemplos:** MMORPGs (World of Warcraft), juegos por turnos\n\n## Ejemplos Concretos\n\n::: {.columns}\n::: {.column width=\"50%\"}\n**World of Warcraft (TCP):**\n\n- Hechizos necesitan entrega garantizada\n- Actualizaciones de inventario críticas\n- Estado de misiones consistente\n- MMORPGs toleran 100-200ms\n:::\n\n::: {.column width=\"50%\"}\n**Counter Strike (UDP):**\n\n- Retroalimentación inmediata crítica\n- Actualizaciones posición/disparos\n- Técnicas de interpolación en cliente\n- Mitiga efecto paquetes perdidos\n:::\n:::\n\n# Resumen\n\n## Puntos Clave\n\n::: {.incremental}\n- La capa de transporte proporciona comunicación lógica entre **procesos**\n- **UDP:** Minimalista, best-effort, no orientado a conexión\n- **TCP:** Confiable, ordenado, orientado a conexión\n- **Multiplexación:** Múltiples sockets por un medio\n- **Control de flujo:** Evita saturar al receptor\n- **Control de congestión:** Responde a condiciones de red\n- **Trade-off fundamental:** Confiabilidad vs velocidad\n- Elección protocolo depende de requisitos aplicación\n:::\n\n",
    "supporting": [
      "ch1_p4_transport_files"
    ],
    "filters": [],
    "includes": {}
  }
}